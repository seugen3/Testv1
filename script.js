let randomizedQuestions = [

    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Insufficient_Solder[402]",
            "Wrong_Component[304]",
            "FalseCall[003]",
            "Wrong_Orientation[309]",
            "Excess Solder[403]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-1_Wrong_Component[304]",
        "totalFrames": 5
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Component[304]",
            "Missing_Component[306]",
            "Extra_Component[305]",
            "Damaged _Lifted_pad[102]",
            "FalseCall[003]"
        ],
        "correctOption": 0,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-10_Wrong_Component[304]",
        "totalFrames": 148
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Component[304]",
            "FalseCall[003]",
            "Damaged_Leads[303]",
            "Solder_Bridge[409]",
            "Unsoldered_Connection[401]"
        ],
        "correctOption": 0,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-2_Wrong_Component[304]",
        "totalFrames": 172
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Insufficient_Solder[402]",
            "FalseCall[003]",
            "Extra_Component[305]",
            "Improper_Placement[310]",
            "Wrong_Component[304]"
        ],
        "correctOption": 4,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-3_Wrong_Component[304]",
        "totalFrames": 177
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Solder_Balls_Splashes[408]",
            "Wrong_Component[304]",
            "Coplanarity_ Component_Lead[316]",
            "FalseCall[003]",
            "FOD_Debries[011]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-4_Wrong_Component[304]",
        "totalFrames": 35
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "FalseCall[003]",
            "Nonwetting_Dewetting_Solder[404]",
            "Contamination[705]",
            "Wrong_Component[304]",
            "Wrong_Orientation[309]"
        ],
        "correctOption": 3,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-5_Wrong_Component[304]",
        "totalFrames": 175
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Component[304]",
            "Excess Solder[403]",
            "Improper_Placement[310]",
            "Billboarded_Component[311]",
            "FalseCall[003]"
        ],
        "correctOption": 0,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-6_Wrong_Component[304]",
        "totalFrames": 179
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Tombstoned_Component[307]",
            "Wrong_Component[304]",
            "FOD_Debries[011]",
            "FalseCall[003]",
            "Nonwetting_Dewetting_Solder[404]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-7_Wrong_Component[304]",
        "totalFrames": 177
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Damaged_Components[301]",
            "Solder_Bridge[409]",
            "Wrong_Component[304]",
            "Wrong_Orientation[309]",
            "FalseCall[003]"
        ],
        "correctOption": 2,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-8_Wrong_Component[304]",
        "totalFrames": 127
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Contamination[705]",
            "Wrong_Component[304]",
            "Improper_Placement[310]",
            "FalseCall[003]",
            "Excess Solder[403]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-9_Wrong_Component[304]",
        "totalFrames": 123
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "FalseCall[003]",
            "Improper_Placement[310]",
            "Damaged _Lifted_pad[102]",
            "Insufficient_Solder[402]",
            "Excess Solder[403]"
        ],
        "correctOption": 2,
        "framesFolder": "GIFs\\_Damaged _Lifted_pad[102]\\5-2_Damaged _Lifted_pad[102]",
        "totalFrames": 170
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Coplanarity_ Component_Lead[316]",
            "Damaged _Lifted_pad[102]",
            "Solder_Balls_Splashes[408]",
            "Tombstoned_Component[307]",
            "FalseCall[003]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Damaged _Lifted_pad[102]\\5-3_Damaged _Lifted_pad[102]",
        "totalFrames": 165
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Missing_Component[306]",
            "FalseCall[003]",
            "Wrong_Orientation[309]",
            "Damaged _Lifted_pad[102]",
            "Damaged_Leads[303]"
        ],
        "correctOption": 3,
        "framesFolder": "GIFs\\_Damaged _Lifted_pad[102]\\5-4_Damaged _Lifted_pad[102]",
        "totalFrames": 177
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Missing_Component[306]",
            "FalseCall[003]",
            "Wrong_Orientation[309]",
            "Damaged_Leads[303]",
            "Wrong_Component[304]"
        ],
        "correctOption": 2,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-1_Wrong_Orientation[309]",
        "totalFrames": 157
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "FalseCall[003]",
            "Contamination[705]",
            "Billboarded_Component[311]",
            "Solder_Bridge[409]",
            "Wrong_Orientation[309]"
        ],
        "correctOption": 4,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-10_Wrong_Orientation[309]",
        "totalFrames": 125
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Excess Solder[403]",
            "FOD_Debries[011]",
            "Wrong_Orientation[309]",
            "FalseCall[003]",
            "Damaged_Components[301]"
        ],
        "correctOption": 2,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-11_Wrong_Orientation[309]",
        "totalFrames": 174
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Unsoldered_Connection[401]",
            "FalseCall[003]",
            "Coplanarity_ Component_Lead[316]",
            "Wrong_Orientation[309]",
            "FOD_Debries[011]"
        ],
        "correctOption": 3,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-12_Wrong_Orientation[309]",
        "totalFrames": 179
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Component[304]",
            "Damaged _Lifted_pad[102]",
            "Wrong_Orientation[309]",
            "Insufficient_Solder[402]",
            "FalseCall[003]"
        ],
        "correctOption": 2,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-15_Wrong_Orientation[309]",
        "totalFrames": 176
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Orientation[309]",
            "Extra_Component[305]",
            "Improper_Placement[310]",
            "Contamination[705]",
            "FalseCall[003]"
        ],
        "correctOption": 0,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-2_Wrong_Orientation[309]",
        "totalFrames": 173
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Insufficient_Solder[402]",
            "Solder_Balls_Splashes[408]",
            "FalseCall[003]",
            "FOD_Debries[011]",
            "Wrong_Orientation[309]"
        ],
        "correctOption": 4,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-3_Wrong_Orientation[309]",
        "totalFrames": 172
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Damaged_Leads[303]",
            "Coplanarity_ Component_Lead[316]",
            "Wrong_Component[304]",
            "Wrong_Orientation[309]",
            "FalseCall[003]"
        ],
        "correctOption": 3,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-4_Wrong_Orientation[309]",
        "totalFrames": 178
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Billboarded_Component[311]",
            "Wrong_Orientation[309]",
            "FalseCall[003]",
            "Tombstoned_Component[307]",
            "Insufficient_Solder[402]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-5_Wrong_Orientation[309]",
        "totalFrames": 175
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Orientation[309]",
            "Damaged_Leads[303]",
            "FalseCall[003]",
            "Nonwetting_Dewetting_Solder[404]",
            "Unsoldered_Connection[401]"
        ],
        "correctOption": 0,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-9_Wrong_Orientation[309]",
        "totalFrames": 115
    },
]

const questions = [

    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Insufficient_Solder[402]",
            "Wrong_Component[304]",
            "FalseCall[003]",
            "Wrong_Orientation[309]",
            "Excess Solder[403]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-1_Wrong_Component[304]",
        "totalFrames": 5
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Component[304]",
            "Missing_Component[306]",
            "Extra_Component[305]",
            "Damaged _Lifted_pad[102]",
            "FalseCall[003]"
        ],
        "correctOption": 0,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-10_Wrong_Component[304]",
        "totalFrames": 148
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Component[304]",
            "FalseCall[003]",
            "Damaged_Leads[303]",
            "Solder_Bridge[409]",
            "Unsoldered_Connection[401]"
        ],
        "correctOption": 0,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-2_Wrong_Component[304]",
        "totalFrames": 172
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Insufficient_Solder[402]",
            "FalseCall[003]",
            "Extra_Component[305]",
            "Improper_Placement[310]",
            "Wrong_Component[304]"
        ],
        "correctOption": 4,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-3_Wrong_Component[304]",
        "totalFrames": 177
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Solder_Balls_Splashes[408]",
            "Wrong_Component[304]",
            "Coplanarity_ Component_Lead[316]",
            "FalseCall[003]",
            "FOD_Debries[011]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-4_Wrong_Component[304]",
        "totalFrames": 35
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "FalseCall[003]",
            "Nonwetting_Dewetting_Solder[404]",
            "Contamination[705]",
            "Wrong_Component[304]",
            "Wrong_Orientation[309]"
        ],
        "correctOption": 3,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-5_Wrong_Component[304]",
        "totalFrames": 175
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Component[304]",
            "Excess Solder[403]",
            "Improper_Placement[310]",
            "Billboarded_Component[311]",
            "FalseCall[003]"
        ],
        "correctOption": 0,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-6_Wrong_Component[304]",
        "totalFrames": 179
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Tombstoned_Component[307]",
            "Wrong_Component[304]",
            "FOD_Debries[011]",
            "FalseCall[003]",
            "Nonwetting_Dewetting_Solder[404]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-7_Wrong_Component[304]",
        "totalFrames": 177
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Damaged_Components[301]",
            "Solder_Bridge[409]",
            "Wrong_Component[304]",
            "Wrong_Orientation[309]",
            "FalseCall[003]"
        ],
        "correctOption": 2,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-8_Wrong_Component[304]",
        "totalFrames": 127
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Contamination[705]",
            "Wrong_Component[304]",
            "Improper_Placement[310]",
            "FalseCall[003]",
            "Excess Solder[403]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Wrong_Component[304]\\8-9_Wrong_Component[304]",
        "totalFrames": 123
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "FalseCall[003]",
            "Improper_Placement[310]",
            "Damaged _Lifted_pad[102]",
            "Insufficient_Solder[402]",
            "Excess Solder[403]"
        ],
        "correctOption": 2,
        "framesFolder": "GIFs\\_Damaged _Lifted_pad[102]\\5-2_Damaged _Lifted_pad[102]",
        "totalFrames": 170
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Coplanarity_ Component_Lead[316]",
            "Damaged _Lifted_pad[102]",
            "Solder_Balls_Splashes[408]",
            "Tombstoned_Component[307]",
            "FalseCall[003]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Damaged _Lifted_pad[102]\\5-3_Damaged _Lifted_pad[102]",
        "totalFrames": 165
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Missing_Component[306]",
            "FalseCall[003]",
            "Wrong_Orientation[309]",
            "Damaged _Lifted_pad[102]",
            "Damaged_Leads[303]"
        ],
        "correctOption": 3,
        "framesFolder": "GIFs\\_Damaged _Lifted_pad[102]\\5-4_Damaged _Lifted_pad[102]",
        "totalFrames": 177
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Missing_Component[306]",
            "FalseCall[003]",
            "Wrong_Orientation[309]",
            "Damaged_Leads[303]",
            "Wrong_Component[304]"
        ],
        "correctOption": 2,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-1_Wrong_Orientation[309]",
        "totalFrames": 157
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "FalseCall[003]",
            "Contamination[705]",
            "Billboarded_Component[311]",
            "Solder_Bridge[409]",
            "Wrong_Orientation[309]"
        ],
        "correctOption": 4,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-10_Wrong_Orientation[309]",
        "totalFrames": 125
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Excess Solder[403]",
            "FOD_Debries[011]",
            "Wrong_Orientation[309]",
            "FalseCall[003]",
            "Damaged_Components[301]"
        ],
        "correctOption": 2,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-11_Wrong_Orientation[309]",
        "totalFrames": 174
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Unsoldered_Connection[401]",
            "FalseCall[003]",
            "Coplanarity_ Component_Lead[316]",
            "Wrong_Orientation[309]",
            "FOD_Debries[011]"
        ],
        "correctOption": 3,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-12_Wrong_Orientation[309]",
        "totalFrames": 179
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Component[304]",
            "Damaged _Lifted_pad[102]",
            "Wrong_Orientation[309]",
            "Insufficient_Solder[402]",
            "FalseCall[003]"
        ],
        "correctOption": 2,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-15_Wrong_Orientation[309]",
        "totalFrames": 176
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Orientation[309]",
            "Extra_Component[305]",
            "Improper_Placement[310]",
            "Contamination[705]",
            "FalseCall[003]"
        ],
        "correctOption": 0,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-2_Wrong_Orientation[309]",
        "totalFrames": 173
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Insufficient_Solder[402]",
            "Solder_Balls_Splashes[408]",
            "FalseCall[003]",
            "FOD_Debries[011]",
            "Wrong_Orientation[309]"
        ],
        "correctOption": 4,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-3_Wrong_Orientation[309]",
        "totalFrames": 172
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Damaged_Leads[303]",
            "Coplanarity_ Component_Lead[316]",
            "Wrong_Component[304]",
            "Wrong_Orientation[309]",
            "FalseCall[003]"
        ],
        "correctOption": 3,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-4_Wrong_Orientation[309]",
        "totalFrames": 178
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Billboarded_Component[311]",
            "Wrong_Orientation[309]",
            "FalseCall[003]",
            "Tombstoned_Component[307]",
            "Insufficient_Solder[402]"
        ],
        "correctOption": 1,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-5_Wrong_Orientation[309]",
        "totalFrames": 175
    },
    {
        "question": "Evalua\u021bi imaginea din punct de vedere al inspectiei AOI",
        "options": [
            "Wrong_Orientation[309]",
            "Damaged_Leads[303]",
            "FalseCall[003]",
            "Nonwetting_Dewetting_Solder[404]",
            "Unsoldered_Connection[401]"
        ],
        "correctOption": 0,
        "framesFolder": "GIFs\\_Wrong_Orientation[309]\\12-9_Wrong_Orientation[309]",
        "totalFrames": 115
    },
];

// Inline JSON data for questions (already provided)
let isReviewMode = false; // Default is false
let currentQuestionIndex = 0;
let zoomLevel = 1; // Initial zoom level
let isDragging = false; // Dragging state
let dragStartX = 0; // Initial mouse X position
let dragStartY = 0; // Initial mouse Y position
let imageTranslateX = 0; // Current image translation on X-axis
let imageTranslateY = 0; // Current image translation on Y-axis;
let timerInterval; // To store the interval
let timeRemaining = 30 * 60; // 30 minutes in seconds
let incorrectAnswers = 0; // Track incorrect answers
const maxIncorrectAnswers = 2; // Allow up to 2 incorrect answers

document.addEventListener("DOMContentLoaded", () => {
    const loginForm = document.getElementById("loginForm");
    const loginError = document.getElementById("loginError");
    const startTestButton = document.getElementById("startTestButton");

    const validCredentials = {
        username: "testuser",
        password: "testpassword",
    };

    loginForm.addEventListener("submit", (e) => {
        e.preventDefault(); // Prevent form submission
        const username = document.getElementById("username").value;
        const password = document.getElementById("password").value;

        if (username === validCredentials.username && password === validCredentials.password) {
            loginError.classList.add("hidden");
            loginForm.classList.add("hidden");
            startTestButton.classList.remove("hidden");
        } else {
            loginError.classList.remove("hidden");
        }
    });
});



const draggableBox = document.getElementById('draggableBox');



function startTimer() {
    const timerElement = document.getElementById('timer');

    timerInterval = setInterval(() => {
        // Calculate minutes and seconds
        const minutes = Math.floor(timeRemaining / 60);
        const seconds = timeRemaining % 60;

        // Update the timer display
        timerElement.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;

        // Check if time has run out
        if (timeRemaining <= 0) {
            clearInterval(timerInterval); // Stop the timer
            alert("Timpul a expirat! Testul s-a încheiat.");
            showResults(); // Show the results page
        }

        timeRemaining--; // Decrease time
    }, 1000);
}






// Utility function to shuffle an array
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

// Shuffle and select 4 questions
function shuffleAndSelectQuestions() {
    const shuffled = questions.sort(() => Math.random() - 0.5);
    randomizedQuestions = shuffled.slice(0, 22); // Select 22 questions after shuffling

    // Start the timer when the test begins
    startTimer();
}

// Variables to store user answers
const userAnswers = [];





// Show results after the last question
// Show results after the last question
function showResults() {
    console.log("Executing showResults...");
    clearInterval(timerInterval);

    const resultsPage = document.getElementById('resultsPage');
    const questionsPage = document.querySelector('.container');
    const draggableBox = document.getElementById('draggableBox');

    // Hide the slider container when showing results
    draggableBox.classList.add('hidden');

    // Calculate score
    const correctAnswers = userAnswers.filter(answer => answer.selectedOption === answer.correctOption).length;
    const totalQuestions = randomizedQuestions.length;
    const score = Math.round((correctAnswers / totalQuestions) * 100);

    // Update DOM elements for results
    const resultMessage = document.getElementById('resultMessage');
    const scoreMessage = document.getElementById('scoreMessage');
    const reviewList = document.getElementById('reviewList');

    resultMessage.innerText = score >= 90 ? 'Ai trecut testul! Felicitări!' : 'Nu ai trecut testul. Încearcă din nou!';
    scoreMessage.innerText = `Scorul tău: ${score}%`;

    reviewList.innerHTML = '';
    userAnswers.forEach((answer, index) => {
        const li = document.createElement('li');
        li.innerHTML = `<strong>Întrebarea ${index + 1}:</strong> ${answer.question}<br>
                        <span style="color: ${answer.selectedOption === answer.correctOption ? 'green' : 'red'};">
                        Răspuns ales: ${answer.selectedOption}</span><br>
                        Răspuns corect: ${answer.correctOption}`;
        reviewList.appendChild(li);
    });

    // Switch views
    questionsPage.classList.add('hidden');
    resultsPage.classList.remove('hidden');
    console.log("Results page should now be visible.");
}

// Restart the test
function restartTest() {
    isReviewMode = false;
    currentQuestionIndex = 0;
    userAnswers.length = 0;
    shuffleAndSelectQuestions();
    displayQuestion(currentQuestionIndex);

    // Reset the timer
    clearInterval(timerInterval); // Clear the current timer interval
    timeRemaining = 30 * 60; // Reset the time to 30 minutes
    startTimer(); // Restart the timer

    // Ensure the slider is visible when restarting the test
    const draggableBox = document.getElementById('draggableBox');
    draggableBox.classList.remove('hidden');

    // Reset the results page and show the test page
    document.getElementById('resultsPage').classList.add('hidden');
    document.querySelector('.container').classList.remove('hidden');
}





// Add event listeners for results page buttons
document.getElementById('reviewQuestionsButton').addEventListener('click', () => {
    isReviewMode = true; // Enable review mode
    currentQuestionIndex = 0;
    displayQuestion(currentQuestionIndex);

    document.getElementById('resultsPage').classList.add('hidden');
    document.querySelector('.container').classList.remove('hidden');
});


document.getElementById('restartButton').addEventListener('click', restartTest);



// Navigate between questions
// Navigate between questions
function nextQuestion() {
    if (!isReviewMode) {
        // Validate the current answer
        const userAnswer = userAnswers[currentQuestionIndex];
        if (userAnswer && userAnswer.selectedOption !== userAnswer.correctOption) {
            incorrectAnswers++; // Increment incorrect answer count
        }
    }

    // Move to the next question only if within bounds
    if (currentQuestionIndex < randomizedQuestions.length - 1) {
        currentQuestionIndex++; // Increment only once
        displayQuestion(currentQuestionIndex); // Load the next question
    } else {
        showResults(); // Show results after all questions are answered
    }
}




function prevQuestion() {
    if (currentQuestionIndex > 0) {
        currentQuestionIndex--;
        displayQuestion(currentQuestionIndex);
    }
}

draggableBox.classList.remove('hidden');

// Enable slider during review mode
function displayQuestion(index) {
    const question = randomizedQuestions[index];
    const header = document.querySelector('.header');
    const draggableBox = document.getElementById('draggableBox');

    // Update the question counter
    const questionCounter = document.getElementById('questionCounter');
    questionCounter.textContent = `${index + 1}/${randomizedQuestions.length}`;

    // Update the header based on review mode
    if (isReviewMode) {
        const userAnswer = userAnswers[index];
        if (userAnswer && userAnswer.selectedOption === question.options[question.correctOption]) {
            header.style.backgroundColor = 'green'; // Correct answer
            header.firstChild.textContent = 'Corect'; // Update only the text part
        } else {
            header.style.backgroundColor = 'red'; // Incorrect answer
            header.firstChild.textContent = 'Incorect'; // Update only the text part
        }
    } else {
        header.style.backgroundColor = '#c62828'; // Default red header
        header.firstChild.textContent = 'Alege varianta corectă'; // Update only the text part
    }

    // Shuffle the options for the current question
    const shuffledOptions = isReviewMode ? question.options : shuffleArray([...question.options]);

    document.querySelector('.options-section h2').innerText = question.question;

    const optionsList = document.querySelector('.options-section ul');
    optionsList.innerHTML = ''; // Clear previous options

    shuffledOptions.forEach((option, i) => {
        const li = document.createElement('li');
        li.style.cursor = isReviewMode ? 'not-allowed' : 'pointer'; // Disable pointer cursor in review mode

        // Create the HTML for the option row
        li.innerHTML = `
            <div style="display: flex; align-items: center;">
                <input type="radio" name="option" id="option${i}" value="${i}" style="margin-right: 10px;" ${isReviewMode ? 'disabled' : ''}>
                <label for="option${i}" style="flex: 1;">${option}</label>
            </div>
        `;

        const radioInput = li.querySelector('input[type="radio"]');

        // Restore previously selected answer if it exists
        if (userAnswers[index]?.selectedOption === option) {
            radioInput.checked = true; // Mark as selected
        }

        if (!isReviewMode) {
            // Add click event listener to save the user's answer
            li.addEventListener('click', () => {
                radioInput.checked = true; // Select the radio button programmatically

                // Save the user's answer
                userAnswers[index] = {
                    question: question.question,
                    selectedOption: option,
                    correctOption: question.options[question.correctOption],
                };

                // Highlight the selected option in red
                const allOptions = optionsList.querySelectorAll('li label');
                allOptions.forEach((label) => {
                    label.style.backgroundColor = 'transparent';
                    label.style.color = 'inherit';
                });
                li.querySelector('label').style.backgroundColor = '#C12033';
                li.querySelector('label').style.color = 'white';

                // Save the answer to local storage
                const questionId = `q${index + 1}`;
                const isCorrect = option === question.options[question.correctOption];
                saveAnswer(questionId, isCorrect); // Save using the saveAnswer function
            });
        } else {
            // Highlight the user's selected answer and the correct answer
            const label = li.querySelector('label');
            if (option === question.options[question.correctOption]) {
                label.style.border = '2px solid green'; // Highlight correct answer in green
            }
            if (userAnswers[index]?.selectedOption === option) {
                label.style.backgroundColor = 'red'; // Highlight user's incorrect selection in red
                label.style.color = 'white'; // Keep text color white
            }
        }

        optionsList.appendChild(li);
    });

    loadFrames(question.framesFolder, question.totalFrames);
}






function goToResults() {
    document.querySelector('.container').classList.add('hidden');
    document.getElementById('resultsPage').classList.remove('hidden');
}



// Restore zoom and drag functionality for the modal
function loadFrames(folder, totalFrames) {
    const frames = [];
    for (let i = 1; i <= totalFrames; i++) {
        frames.push(`${folder}/frame_${i}.png`);
    }

    const gifFrame = document.getElementById('gifFrame');
    const frameSlider = document.getElementById('frameSlider');

    // Set slider max dynamically
    frameSlider.max = totalFrames;
    frameSlider.value = 1;
    gifFrame.src = frames[0]; // Load the first frame

    // Ensure the slider changes frames even during zoom
    frameSlider.oninput = () => {
        const frameIndex = Math.min(frameSlider.value - 1, totalFrames - 1); // Prevent exceeding range
        gifFrame.src = frames[frameIndex]; // Update the image source
    };

    // Add click event for fullscreen modal
    gifFrame.onclick = () => openModal(gifFrame.src);

    // Add scroll event for zooming
    gifFrame.addEventListener('wheel', handleScrollZoom);
}




// Modal functionality
// Restore modal functionality
function openModal(imageSrc) {
    const modal = document.getElementById('imageModal');
    const modalImage = document.getElementById('modalImage');
    const closeModal = document.querySelector('.modal .close');

    zoomLevel = 1; // Reset zoom level when opening modal
    imageTranslateX = 0;
    imageTranslateY = 0;
    modalImage.style.transform = `scale(${zoomLevel}) translate(0, 0)`; // Reset zoom and translation
    modalImage.src = imageSrc; // Set the modal image source
    modal.style.display = 'block'; // Show the modal

    // Close the modal when the close button is clicked
    closeModal.onclick = () => {
        modal.style.display = 'none';
    };

    // Close the modal when clicking outside the image
    modal.onclick = (event) => {
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    };

    // Add drag functionality to the modal image
    modalImage.onmousedown = startDragging;
    document.onmouseup = stopDragging;
    document.onmousemove = dragImage;

    // Zoom in and out
    const zoomInButton = document.getElementById('zoomIn');
    const zoomOutButton = document.getElementById('zoomOut');

    zoomInButton.onclick = () => zoomModalImage(0.3); // Zoom in
    zoomOutButton.onclick = () => zoomModalImage(-0.5); // Zoom out
}

// Start dragging the image
function startDragging(event) {
    isDragging = true;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    event.preventDefault(); // Prevent selection while dragging
}

// Stop dragging the image
function stopDragging() {
    isDragging = false;
}

// Drag the image
function dragImage(event) {
    if (!isDragging) return;

    const deltaX = event.clientX - dragStartX;
    const deltaY = event.clientY - dragStartY;

    imageTranslateX += deltaX / zoomLevel; // Adjust for zoom level
    imageTranslateY += deltaY / zoomLevel;

    const modalImage = document.getElementById('modalImage');
    modalImage.style.transform = `scale(${zoomLevel}) translate(${imageTranslateX}px, ${imageTranslateY}px)`;

    dragStartX = event.clientX;
    dragStartY = event.clientY;
}

// Zoom the modal image
function zoomModalImage(step) {
    zoomLevel += step;
    zoomLevel = Math.max(1, zoomLevel); // Prevent zooming out below 1x
    const modalImage = document.getElementById('modalImage');
    modalImage.style.transform = `scale(${zoomLevel}) translate(${imageTranslateX}px, ${imageTranslateY}px)`; // Apply zoom and translation
}

// Function to handle zoom using the scroll wheel
function handleScrollZoom(event) {
    event.preventDefault(); // Prevent the default scrolling behavior
    const zoomStep = event.deltaY < 0 ? 0.1 : -0.1; // Scroll up to zoom in, down to zoom out
    zoomLevel += zoomStep;
    zoomLevel = Math.max(1, Math.min(zoomLevel, 5)); // Clamp zoom level between 1x and 5x

    const modalImage = document.getElementById('modalImage');
    modalImage.style.transform = `scale(${zoomLevel}) translate(${imageTranslateX}px, ${imageTranslateY}px)`;
}

// Add the event listener to the image for scroll wheel zoom
const gifFrame = document.getElementById('gifFrame');
gifFrame.addEventListener('wheel', handleScrollZoom);

// Also add the listener for modal zoom if needed
const modalImage = document.getElementById('modalImage');
modalImage.addEventListener('wheel', handleScrollZoom);


const slider = document.getElementById('frameSlider');
const tooltip = document.getElementById('sliderTooltip');


// Local AOI Test System with User Tracking and Admin Dashboard

// Dummy user database
const users = [
    { id: "user1", name: "User 1", role: "user", answers: {} },
    { id: "user2", name: "User 2", role: "user", answers: {} },
    { id: "user3", name: "User 3", role: "user", answers: {} },
    { id: "admin", name: "Admin", role: "admin", answers: {} }
];

// Save users to localStorage
if (!localStorage.getItem("users")) {
    localStorage.setItem("users", JSON.stringify(users));
}

// Login function
function login(username) {
    const storedUsers = JSON.parse(localStorage.getItem("users"));
    const user = storedUsers.find(u => u.id === username);

    if (user) {
        localStorage.setItem("currentUser", JSON.stringify(user));
        if (user.role === "admin") {
            window.location.href = "admin.html";
        } else {
            window.location.href = "Test_AOI.html";
        }
    } else {
        alert("Invalid user!");
    }
}

// Save answer function
function saveAnswer(questionId, isCorrect) {
    const currentUser = JSON.parse(localStorage.getItem("currentUser"));
    const storedUsers = JSON.parse(localStorage.getItem("users"));

    // Update user answers
    currentUser.answers[questionId] = isCorrect ? "correct" : "wrong";

    // Update global user database
    const userIndex = storedUsers.findIndex(u => u.id === currentUser.id);
    storedUsers[userIndex] = currentUser;
    localStorage.setItem("users", JSON.stringify(storedUsers));
    localStorage.setItem("currentUser", JSON.stringify(currentUser));
}


// Admin view function
function loadAdminDashboard() {
    const storedUsers = JSON.parse(localStorage.getItem("users")); // Fetch user data from local storage
    const resultsContainer = document.getElementById("resultsContainer"); // Admin results container

    resultsContainer.innerHTML = ""; // Clear previous content

    if (!randomizedQuestions || randomizedQuestions.length === 0) {
        resultsContainer.innerHTML = "<p>No question data available. Ensure randomizedQuestions is defined.</p>";
        console.error("RandomizedQuestions is not defined or empty!");
        return;
    }

    if (storedUsers) {
        storedUsers.forEach(user => {
            if (user.role === "user") {
                // Create a section for each user
                const userSection = document.createElement("div");
                userSection.innerHTML = `<h3>${user.name}</h3>`;

                const userAnswers = user.answers || {};

                if (Object.keys(userAnswers).length > 0) {
                    const questionResults = Object.entries(userAnswers).map(([questionId, status]) => {
                        // Get the question index (e.g., q1 -> 0, q2 -> 1, etc.)
                        const questionIndex = parseInt(questionId.replace('q', '')) - 1;

                        // Ensure the question exists in randomizedQuestions
                        if (randomizedQuestions[questionIndex]) {
                            const question = randomizedQuestions[questionIndex];
                            return `
                                <p>
                                    <strong>Question:</strong> ${question.question} <br>
                                    <strong>Your Answer:</strong> ${status === "correct" ? "Correct" : "Wrong"} <br>
                                    <strong>Correct Answer:</strong> ${question.options[question.correctOption]}
                                </p>
                            `;
                        } else {
                            return `<p>Question data not found for ${questionId}</p>`;
                        }
                    }).join("");

                    userSection.innerHTML += questionResults;
                } else {
                    userSection.innerHTML += "<p>No answers yet</p>";
                }

                resultsContainer.appendChild(userSection);
            }
        });
    } else {
        resultsContainer.innerHTML = "<p>No user data found</p>";
    }
}



// Logout function
function logout() {
    localStorage.removeItem("currentUser");
    window.location.href = "landing.html";
}

// Example usage
// Call `saveAnswer('q1', true)` when a user answers a question.
// Call `loadAdminDashboard()` on the admin page to display all results.


// Initialize
shuffleAndSelectQuestions();
displayQuestion(currentQuestionIndex);

